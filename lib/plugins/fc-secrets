#!/usr/bin/env bash

# ==============================================================================
#
# FILE:         fc-secrets
#
# DESCRIPTION:  Unified secrets management command that integrates with multiple
#               secrets managers (1Password, macOS Keychain, HashiCorp Vault)
#               to fetch secrets and sync them to environment variables or files.
#
# USAGE:        fc secrets <subcommand> [options]
#
# SUBCOMMANDS:
#   setup       Create configuration files and check prerequisites
#   sync        Sync all secrets from config to their destinations
#   get <uri>   Fetch a single secret and print to stdout
#   list        List configured secrets and their sync status
#   status      Show backend authentication status
#   verify      Verify all secrets are accessible (dry-run)
#
# BACKENDS:
#   op://       - 1Password CLI
#   keychain:// - macOS Keychain
#   vault://    - HashiCorp Vault
#
# ==============================================================================

# --- Initialization ---------------------------------------------------------
source "$(dirname "${BASH_SOURCE[0]}")/../init.sh"

# --- Configuration ---
readonly SECRETS_CONFIG_FILE="$HOME/.config/circus/secrets.conf"
readonly SECRETS_CONFIG_TEMPLATE="$DOTFILES_ROOT/lib/templates/secrets.conf.template"
readonly SECRETS_BACKENDS_DIR="$DOTFILES_ROOT/lib/secrets_backends"

# Default environment file for env: destinations
SECRETS_ENV_FILE="${SECRETS_ENV_FILE:-$HOME/.zshenv.local}"
readonly SECRETS_ENV_MARKER_START="# --- fc-secrets managed (DO NOT EDIT BELOW) ---"
readonly SECRETS_ENV_MARKER_END="# --- fc-secrets end ---"

# State tracking
declare -a SYNC_RESULTS=()
SYNC_SUCCESS=0
SYNC_FAILED=0

# --- Help and Usage ---------------------------------------------------------
usage() {
  msg_info "Usage: fc fc-secrets <subcommand> [options]"
  echo ""
  msg_info "Unified secrets management for 1Password, Keychain, and Vault."
  echo ""
  msg_info "Subcommands:"
  echo "  setup           Create configuration file and check prerequisites"
  echo "  sync            Sync all secrets from config to destinations"
  echo "  get <uri>       Fetch a single secret (prints to stdout)"
  echo "  list            List configured secrets and sync status"
  echo "  status          Show backend authentication status"
  echo "  verify          Verify all secrets are accessible (dry-run)"
  echo ""
  msg_info "Options:"
  echo "  --help          Show this help message"
  echo ""
  msg_info "Backends:"
  echo "  op://           1Password CLI (requires 'op' command)"
  echo "  keychain://     macOS Keychain (built-in)"
  echo "  vault://        HashiCorp Vault (requires 'vault' command)"
  echo ""
  msg_info "Examples:"
  echo "  fc fc-secrets setup                              # Initial setup"
  echo "  fc fc-secrets sync                               # Sync all secrets"
  echo "  fc fc-secrets get op://Personal/github/token     # Get single secret"
  echo "  fc fc-secrets status                             # Check backend auth"
  echo ""
  msg_info "Configuration: $SECRETS_CONFIG_FILE"
  exit 0
}

# --- Backend Management -----------------------------------------------------

# Parse backend name from URI
parse_backend_from_uri() {
  local uri="$1"
  case "$uri" in
    op://*)       echo "op" ;;
    keychain://*) echo "keychain" ;;
    vault://*)    echo "vault" ;;
    *)            echo "" ;;
  esac
}

# Extract path from URI (remove backend prefix)
extract_path_from_uri() {
  local uri="$1"
  echo "${uri#*://}"
}

# Load a backend plugin
load_backend() {
  local backend_name="$1"
  local backend_file="$SECRETS_BACKENDS_DIR/${backend_name}.sh"

  if [ ! -f "$backend_file" ]; then
    die "Unknown secrets backend: $backend_name"
  fi

  source "$backend_file"
}

# Check if backend is available and authenticated
check_backend_status() {
  local backend_name="$1"
  load_backend "$backend_name"

  local deps_ok=false
  local auth_ok=false

  if secrets_backend_check_dependencies; then
    deps_ok=true
    if secrets_backend_check_auth; then
      auth_ok=true
    fi
  fi

  if $deps_ok && $auth_ok; then
    echo "ready"
  elif $deps_ok; then
    echo "not_authenticated"
  else
    echo "not_installed"
  fi
}

# --- Destination Handlers ---------------------------------------------------

# Write secret to environment file
write_to_env_file() {
  local var_name="$1"
  local value="$2"

  # Create env file if it doesn't exist
  if [ ! -f "$SECRETS_ENV_FILE" ]; then
    touch "$SECRETS_ENV_FILE"
    chmod 600 "$SECRETS_ENV_FILE"
  fi

  # Read existing content
  local existing_content
  existing_content=$(cat "$SECRETS_ENV_FILE" 2>/dev/null || echo "")

  # Check if managed section exists
  if [[ "$existing_content" == *"$SECRETS_ENV_MARKER_START"* ]]; then
    # Extract content before managed section
    local before_section
    before_section=$(echo "$existing_content" | sed -n "1,/${SECRETS_ENV_MARKER_START}/p" | sed '$d')

    # Check if this variable already exists in managed section
    local managed_section
    managed_section=$(echo "$existing_content" | sed -n "/${SECRETS_ENV_MARKER_START}/,/${SECRETS_ENV_MARKER_END}/p")

    # Update or add the variable
    if echo "$managed_section" | grep -q "^export ${var_name}="; then
      # Variable exists, update it
      local new_managed
      new_managed=$(echo "$managed_section" | sed "s|^export ${var_name}=.*|export ${var_name}=\"${value}\"|")
      echo "${before_section}
${new_managed}" > "$SECRETS_ENV_FILE"
    else
      # Variable doesn't exist, add it before the end marker
      local new_managed
      new_managed=$(echo "$managed_section" | sed "s|${SECRETS_ENV_MARKER_END}|export ${var_name}=\"${value}\"\n${SECRETS_ENV_MARKER_END}|")
      echo "${before_section}
${new_managed}" > "$SECRETS_ENV_FILE"
    fi
  else
    # No managed section, create one
    {
      echo "$existing_content"
      echo ""
      echo "$SECRETS_ENV_MARKER_START"
      echo "export ${var_name}=\"${value}\""
      echo "$SECRETS_ENV_MARKER_END"
    } > "$SECRETS_ENV_FILE"
  fi

  chmod 600 "$SECRETS_ENV_FILE"
}

# Write secret to file
write_to_file() {
  local file_path="$1"
  local value="$2"
  local permissions="${3:-600}"

  # Expand tilde
  file_path="${file_path/#\~/$HOME}"

  # Create parent directory if needed
  local parent_dir
  parent_dir=$(dirname "$file_path")
  if [ ! -d "$parent_dir" ]; then
    mkdir -p "$parent_dir"
    chmod 700 "$parent_dir"
  fi

  # Write secret to file
  echo -n "$value" > "$file_path"
  chmod "$permissions" "$file_path"
}

# --- Config File Parsing ----------------------------------------------------

# Parse and process secrets config file
parse_config_file() {
  local callback="$1"

  if [ ! -f "$SECRETS_CONFIG_FILE" ]; then
    die "Configuration file not found: $SECRETS_CONFIG_FILE\nRun 'fc fc-secrets setup' first."
  fi

  # Read config, skip comments and empty lines
  while IFS= read -r line || [ -n "$line" ]; do
    # Skip comments and empty lines
    [[ "$line" =~ ^[[:space:]]*# ]] && continue
    [[ -z "${line// }" ]] && continue

    # Skip variable assignments (SECRETS_ENV_FILE=, VAULT_ADDR=, etc.)
    [[ "$line" =~ ^[A-Z_]+= ]] && continue

    # Parse the line: "uri" "destination" [permissions]
    # Use eval to handle quoted strings properly
    local parts
    eval "parts=($line)" 2>/dev/null || continue

    local uri="${parts[0]}"
    local destination="${parts[1]}"
    local permissions="${parts[2]:-600}"

    # Skip if missing required parts
    [ -z "$uri" ] || [ -z "$destination" ] && continue

    # Call the callback function
    "$callback" "$uri" "$destination" "$permissions"
  done < "$SECRETS_CONFIG_FILE"
}

# --- Subcommands ------------------------------------------------------------

# Setup: Create config file and check prerequisites
do_setup() {
  msg_info "Setting up fc-secrets..."
  echo ""

  # Create config directory
  local config_dir
  config_dir=$(dirname "$SECRETS_CONFIG_FILE")
  if [ ! -d "$config_dir" ]; then
    mkdir -p "$config_dir"
    chmod 700 "$config_dir"
  fi

  # Create config file from template
  if [ -f "$SECRETS_CONFIG_FILE" ]; then
    msg_info "Configuration file already exists: $SECRETS_CONFIG_FILE"
  else
    if [ -f "$SECRETS_CONFIG_TEMPLATE" ]; then
      cp "$SECRETS_CONFIG_TEMPLATE" "$SECRETS_CONFIG_FILE"
      chmod 600 "$SECRETS_CONFIG_FILE"
      msg_success "Configuration file created: $SECRETS_CONFIG_FILE"
    else
      msg_error "Template not found: $SECRETS_CONFIG_TEMPLATE"
    fi
  fi

  echo ""
  msg_info "Checking backend prerequisites..."
  echo ""

  # Check each backend
  local backends=("op" "keychain" "vault")
  for backend in "${backends[@]}"; do
    load_backend "$backend"
    local name
    name=$(secrets_backend_get_name)

    printf "  %-20s " "$name:"

    if secrets_backend_check_dependencies; then
      if secrets_backend_check_auth; then
        echo "${UI_SUCCESS}Ready${UI_RESET}"
      else
        echo "${UI_WARNING}Not authenticated${UI_RESET}"
      fi
    else
      echo "${UI_MUTED}Not installed${UI_RESET}"
    fi
  done

  echo ""
  msg_info "Next steps:"
  echo "  1. Edit the config file: \$EDITOR $SECRETS_CONFIG_FILE"
  echo "  2. Add your secrets using the documented format"
  echo "  3. Run 'fc fc-secrets sync' to sync secrets"
  echo ""
  msg_info "For backend-specific help:"
  echo "  fc fc-secrets get --help op"
  echo "  fc fc-secrets get --help keychain"
  echo "  fc fc-secrets get --help vault"
}

# Sync: Sync all secrets from config
do_sync() {
  msg_info "Syncing secrets..."
  echo ""

  # Check config file exists before sourcing
  if [ ! -f "$SECRETS_CONFIG_FILE" ]; then
    die "Configuration file not found: $SECRETS_CONFIG_FILE\nRun 'fc fc-secrets setup' first."
  fi

  # Source config file for variables like VAULT_ADDR
  # shellcheck disable=SC1090
  source "$SECRETS_CONFIG_FILE"

  local total=0
  local synced=0
  local failed=0

  # Callback for each secret
  sync_secret() {
    local uri="$1"
    local destination="$2"
    local permissions="$3"

    ((total++))

    local backend
    backend=$(parse_backend_from_uri "$uri")
    if [ -z "$backend" ]; then
      msg_error "Unknown backend in URI: $uri"
      ((failed++))
      return
    fi

    local path
    path=$(extract_path_from_uri "$uri")

    # Load backend
    load_backend "$backend"

    # Check dependencies
    if ! secrets_backend_check_dependencies; then
      local name
      name=$(secrets_backend_get_name)
      msg_error "$name is not installed"
      ((failed++))
      return
    fi

    # Check auth
    if ! secrets_backend_check_auth; then
      local name
      name=$(secrets_backend_get_name)
      msg_warning "$name: Not authenticated. Attempting to authenticate..."
      if ! secrets_backend_authenticate; then
        msg_error "Failed to authenticate with $name"
        ((failed++))
        return
      fi
    fi

    # Fetch secret
    local secret_value
    secret_value=$(secrets_backend_get_secret "$path")
    if [ $? -ne 0 ] || [ -z "$secret_value" ]; then
      msg_error "Failed to fetch: $uri"
      ((failed++))
      return
    fi

    # Write to destination
    if [[ "$destination" == env:* ]]; then
      local var_name="${destination#env:}"
      write_to_env_file "$var_name" "$secret_value"
      printf "  ${UI_SUCCESS}✓${UI_RESET} %s → %s\n" "$uri" "env:$var_name"
    else
      write_to_file "$destination" "$secret_value" "$permissions"
      printf "  ${UI_SUCCESS}✓${UI_RESET} %s → %s\n" "$uri" "$destination"
    fi

    ((synced++))
  }

  parse_config_file sync_secret

  echo ""
  if [ "$failed" -eq 0 ]; then
    msg_success "Synced $synced of $total secrets successfully."
  else
    msg_warning "Synced $synced of $total secrets. $failed failed."
  fi

  if [ "$synced" -gt 0 ] && [[ -f "$SECRETS_ENV_FILE" ]]; then
    echo ""
    msg_info "Environment variables written to: $SECRETS_ENV_FILE"
    msg_info "Reload your shell or run: source $SECRETS_ENV_FILE"
  fi

  [ "$failed" -gt 0 ] && return 1
  return 0
}

# Get: Fetch a single secret
do_get() {
  local uri="$1"

  # Handle help requests
  if [ "$uri" = "--help" ]; then
    local help_backend="${2:-}"
    if [ -n "$help_backend" ]; then
      load_backend "$help_backend"
      secrets_backend_get_help
    else
      msg_info "Usage: fc fc-secrets get <uri>"
      echo ""
      msg_info "Fetches a single secret and prints to stdout."
      echo ""
      msg_info "Examples:"
      echo "  fc fc-secrets get op://Personal/github/token"
      echo "  fc fc-secrets get keychain://api-service/key"
      echo "  fc fc-secrets get vault://secret/data/app#api_key"
      echo ""
      msg_info "For backend-specific help:"
      echo "  fc fc-secrets get --help op"
      echo "  fc fc-secrets get --help keychain"
      echo "  fc fc-secrets get --help vault"
    fi
    return 0
  fi

  if [ -z "$uri" ]; then
    die "Please provide a secret URI.\nExample: fc fc-secrets get op://vault/item/field"
  fi

  # Source config for variables like VAULT_ADDR
  [ -f "$SECRETS_CONFIG_FILE" ] && source "$SECRETS_CONFIG_FILE" 2>/dev/null

  local backend
  backend=$(parse_backend_from_uri "$uri")
  if [ -z "$backend" ]; then
    die "Unknown backend in URI: $uri\nSupported: op://, keychain://, vault://"
  fi

  local path
  path=$(extract_path_from_uri "$uri")

  load_backend "$backend"

  # Check dependencies
  if ! secrets_backend_check_dependencies; then
    local name
    name=$(secrets_backend_get_name)
    die "$name is not installed."
  fi

  # Check auth (suppress output for get)
  if ! secrets_backend_check_auth; then
    local name
    name=$(secrets_backend_get_name)
    msg_warning "$name: Not authenticated." >&2
    if ! secrets_backend_authenticate; then
      die "Failed to authenticate with $name"
    fi
  fi

  # Fetch and print
  local secret_value
  secret_value=$(secrets_backend_get_secret "$path")
  if [ $? -ne 0 ] || [ -z "$secret_value" ]; then
    die "Failed to fetch secret: $uri"
  fi

  echo "$secret_value"
}

# List: List configured secrets
do_list() {
  msg_info "Configured secrets:"
  echo ""

  if [ ! -f "$SECRETS_CONFIG_FILE" ]; then
    msg_warning "No configuration file found."
    msg_info "Run 'fc fc-secrets setup' to create one."
    return 0
  fi

  printf "  %-10s %-40s %s\n" "Backend" "Secret" "Destination"
  printf "  %-10s %-40s %s\n" "-------" "------" "-----------"

  list_secret() {
    local uri="$1"
    local destination="$2"
    local permissions="$3"

    local backend
    backend=$(parse_backend_from_uri "$uri")

    # Mask the secret path for display
    local path
    path=$(extract_path_from_uri "$uri")
    [ ${#path} -gt 38 ] && path="${path:0:35}..."

    printf "  %-10s %-40s %s\n" "$backend" "$path" "$destination"
  }

  parse_config_file list_secret

  echo ""
}

# Status: Show backend status
do_status() {
  msg_info "Backend status:"
  echo ""

  local backends=("op" "keychain" "vault")
  for backend in "${backends[@]}"; do
    load_backend "$backend"
    local name
    name=$(secrets_backend_get_name)

    printf "  %-20s " "$name:"

    if secrets_backend_check_dependencies; then
      if secrets_backend_check_auth; then
        echo "${UI_SUCCESS}Authenticated${UI_RESET}"
      else
        echo "${UI_WARNING}Not authenticated${UI_RESET}"
      fi
    else
      echo "${UI_MUTED}Not installed${UI_RESET}"
    fi
  done

  echo ""

  # Show env file status
  if [ -f "$SECRETS_ENV_FILE" ]; then
    msg_info "Environment file: $SECRETS_ENV_FILE"

    # Count managed variables
    local managed_count
    managed_count=$(sed -n "/${SECRETS_ENV_MARKER_START}/,/${SECRETS_ENV_MARKER_END}/p" "$SECRETS_ENV_FILE" 2>/dev/null | grep -c "^export " || echo "0")
    msg_info "Managed variables: $managed_count"
  fi
}

# Verify: Check all secrets are accessible
do_verify() {
  msg_info "Verifying secrets accessibility..."
  echo ""

  # Source config for variables
  [ -f "$SECRETS_CONFIG_FILE" ] && source "$SECRETS_CONFIG_FILE" 2>/dev/null

  local total=0
  local accessible=0
  local failed=0

  verify_secret() {
    local uri="$1"
    local destination="$2"
    local permissions="$3"

    ((total++))

    local backend
    backend=$(parse_backend_from_uri "$uri")
    if [ -z "$backend" ]; then
      printf "  ${UI_ERROR}✗${UI_RESET} %s (unknown backend)\n" "$uri"
      ((failed++))
      return
    fi

    local path
    path=$(extract_path_from_uri "$uri")

    load_backend "$backend"

    if ! secrets_backend_check_dependencies; then
      local name
      name=$(secrets_backend_get_name)
      printf "  ${UI_ERROR}✗${UI_RESET} %s (%s not installed)\n" "$uri" "$name"
      ((failed++))
      return
    fi

    if ! secrets_backend_check_auth; then
      local name
      name=$(secrets_backend_get_name)
      printf "  ${UI_WARNING}?${UI_RESET} %s (%s not authenticated)\n" "$uri" "$name"
      ((failed++))
      return
    fi

    # Try to fetch (but don't save)
    local secret_value
    secret_value=$(secrets_backend_get_secret "$path" 2>/dev/null)
    if [ $? -eq 0 ] && [ -n "$secret_value" ]; then
      printf "  ${UI_SUCCESS}✓${UI_RESET} %s\n" "$uri"
      ((accessible++))
    else
      printf "  ${UI_ERROR}✗${UI_RESET} %s (not found or access denied)\n" "$uri"
      ((failed++))
    fi
  }

  parse_config_file verify_secret

  echo ""
  if [ "$failed" -eq 0 ]; then
    msg_success "All $total secrets are accessible."
    return 0
  else
    msg_warning "$accessible of $total secrets accessible. $failed failed."
    return 1
  fi
}

# --- Main -------------------------------------------------------------------
main() {
  if [ -z "${1:-}" ] || [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
    usage
  fi

  local subcommand="$1"
  shift

  case "$subcommand" in
    setup)
      do_setup "$@"
      ;;
    sync)
      do_sync "$@"
      ;;
    get)
      do_get "$@"
      ;;
    list)
      do_list "$@"
      ;;
    status)
      do_status "$@"
      ;;
    verify)
      do_verify "$@"
      ;;
    *)
      die "Unknown subcommand: $subcommand\nRun 'fc fc-secrets --help' for usage."
      ;;
  esac
}

main "$@"
