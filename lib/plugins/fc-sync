#!/usr/bin/env bash

# ==============================================================================
#
# FILE:         sync
#
# DESCRIPTION:  This script handles the encrypted backup and restoration of
#               system state, including application settings, user data, and a
#               list of installed packages. Supports multiple backup backends.
#
# ==============================================================================

# --- Initialization ---------------------------------------------------------
# Source the centralized initialization script to set up the environment.
source "$(dirname "${BASH_SOURCE[0]}")/../init.sh"

# --- Configuration Loading ---

readonly SYNC_CONFIG_FILE="$HOME/.config/circus/sync.conf"
readonly SYNC_CONFIG_TEMPLATE="$DOTFILES_ROOT/lib/templates/sync.conf.template"
readonly BACKUP_BACKENDS_DIR="$DOTFILES_ROOT/lib/backup_backends"

# Default values (can be overridden by config file)
BACKUP_DEST_DIR="${BACKUP_DEST_DIR:-$HOME}"
BACKUP_ARCHIVE_NAME="${BACKUP_ARCHIVE_NAME:-circus_backup.tar.gz.gpg}"
GPG_RECIPIENT_ID=""
BACKUP_TARGETS=()

# Backend selection (default: gpg)
BACKUP_BACKEND="${BACKUP_BACKEND:-gpg}"

# Remote storage defaults (for GPG backend with rclone)
RCLONE_REMOTE=""
RCLONE_REMOTE_PATH="circus-backups"

# Restic backend defaults
RESTIC_REPOSITORY=""
RESTIC_PASSWORD_FILE="$HOME/.config/circus/restic-password"

# Borg backend defaults
BORG_REPOSITORY=""
BORG_PASSPHRASE_FILE="$HOME/.config/circus/borg-passphrase"
BORG_COMPRESSION="zstd"

# Load user configuration if it exists
if [ -f "$SYNC_CONFIG_FILE" ]; then
  # Security check: warn if file is world-writable (check "other" bits)
  perms=$(stat -f '%Lp' "$SYNC_CONFIG_FILE" 2>/dev/null || echo "000")
  other_perms=$((perms % 10))  # Get the last digit (other permissions)
  if [ "$other_perms" -ge 2 ] 2>/dev/null; then
    msg_warning "Config file $SYNC_CONFIG_FILE is world-writable. Consider: chmod 600 $SYNC_CONFIG_FILE"
  fi
  # shellcheck source=/dev/null
  source "$SYNC_CONFIG_FILE"
fi

# --- Backend Loading ---

# Load the selected backup backend
load_backend() {
  local backend_file="$BACKUP_BACKENDS_DIR/${BACKUP_BACKEND}.sh"

  if [ ! -f "$backend_file" ]; then
    msg_error "Unknown backup backend: $BACKUP_BACKEND"
    echo ""
    msg_info "Available backends:"
    for f in "$BACKUP_BACKENDS_DIR"/*.sh; do
      if [ -f "$f" ]; then
        echo "  - $(basename "$f" .sh)"
      fi
    done
    die "Invalid BACKUP_BACKEND in config. Edit $SYNC_CONFIG_FILE to fix."
  fi

  # shellcheck source=/dev/null
  source "$backend_file"
}

# --- Validate Remote Storage Configuration (for GPG backend) ---
validate_remote_config() {
  local rclone_cmd=${RCLONE_CMD:-rclone}

  if [ -z "$RCLONE_REMOTE" ]; then
    msg_error "RCLONE_REMOTE is not configured."
    echo ""
    msg_info "To configure remote storage:"
    msg_info "  1. Configure rclone: rclone config"
    msg_info "  2. Edit: \$EDITOR $SYNC_CONFIG_FILE"
    msg_info "  3. Set RCLONE_REMOTE to your remote name"
    die "Remote storage not configured."
  fi

  # Verify rclone remote exists
  if ! "$rclone_cmd" listremotes 2>/dev/null | grep -q "^${RCLONE_REMOTE}:$"; then
    msg_error "rclone remote '$RCLONE_REMOTE' not found."
    echo ""
    msg_info "Available remotes:"
    "$rclone_cmd" listremotes 2>/dev/null || echo "  (none configured)"
    echo ""
    msg_info "Configure a new remote with: rclone config"
    die "Invalid rclone remote: $RCLONE_REMOTE"
  fi
}

# --- Usage Information ---
usage() {
  msg_info "Usage: fc fc-sync [options] <subcommand>"
  echo ""
  msg_info "Manages the encrypted backup and restoration of system state."
  echo ""
  msg_info "Subcommands:"
  echo "  setup       - Create configuration file from template."
  echo "  backup      - Backs up and encrypts critical data."
  echo "  restore     - Decrypts and restores data from an encrypted backup."
  echo "  push        - Upload local backup to configured remote storage (GPG backend only)."
  echo "  pull        - Download backup from remote storage (GPG backend only)."
  echo "  list-remote - List available backups on remote storage (GPG backend only)."
  echo ""
  msg_info "Options:"
  echo "  --no-confirm  - Skip confirmation prompts (for automated/scheduled use)."
  echo ""
  msg_info "Backup Backends:"
  echo "  gpg    - Default. Uses tar + GPG for encrypted archives. Remote via rclone."
  echo "  restic - Deduplication, incremental backups, native remote support."
  echo "  borg   - Deduplication, compression, native SSH remote support."
  echo ""
  msg_info "Configuration: $SYNC_CONFIG_FILE"
  msg_info "Set BACKUP_BACKEND to choose your backend (default: gpg)."
  msg_info "Remote storage (GPG backend) requires rclone: https://rclone.org/"
  exit 0
}

# --- Command Logic ---

do_setup() {
  local config_dir="$HOME/.config/circus"

  if [ -f "$SYNC_CONFIG_FILE" ]; then
    msg_info "Configuration file already exists: $SYNC_CONFIG_FILE"
    echo ""
    msg_info "Edit it with: \$EDITOR $SYNC_CONFIG_FILE"
    return 0
  fi

  if [ ! -f "$SYNC_CONFIG_TEMPLATE" ]; then
    die "Configuration template not found: $SYNC_CONFIG_TEMPLATE"
  fi

  msg_info "Creating configuration directory..."
  mkdir -p "$config_dir"

  msg_info "Copying configuration template..."
  cp "$SYNC_CONFIG_TEMPLATE" "$SYNC_CONFIG_FILE"
  chmod 600 "$SYNC_CONFIG_FILE"

  msg_success "Configuration file created: $SYNC_CONFIG_FILE"
  echo ""
  msg_info "Next steps:"
  msg_info "  1. Edit the config: \$EDITOR $SYNC_CONFIG_FILE"
  msg_info "  2. Choose your BACKUP_BACKEND (gpg, restic, or borg)"
  msg_info "  3. Configure backend-specific settings"
  msg_info "  4. Customize BACKUP_TARGETS as needed"
  echo ""
  msg_info "For GPG backend: Set GPG_RECIPIENT_ID (find with: gpg --list-keys --keyid-format LONG)"
  msg_info "For Restic backend: Set RESTIC_REPOSITORY and create RESTIC_PASSWORD_FILE"
  msg_info "For Borg backend: Set BORG_REPOSITORY and create BORG_PASSPHRASE_FILE"
}

# --- Remote Storage Commands (GPG backend with rclone) ---

check_remote_dependencies() {
  local rclone_cmd=${RCLONE_CMD:-rclone}

  if ! command -v "$rclone_cmd" >/dev/null 2>&1; then
    msg_error "rclone is not installed."
    echo ""
    msg_info "Install rclone with: brew install rclone"
    msg_info "Then configure a remote with: rclone config"
    die "rclone required for remote storage operations."
  fi
}

do_push() {
  # Check if backend handles remote natively
  if backend_handles_remote; then
    msg_info "Backend '$(backend_get_name)' has native remote support."
    echo ""
    msg_info "Configure your remote destination in the backend-specific settings:"
    if [ "$BACKUP_BACKEND" = "restic" ]; then
      msg_info "  Set RESTIC_REPOSITORY to a remote path (e.g., s3:bucket/path, sftp:host/path)"
    elif [ "$BACKUP_BACKEND" = "borg" ]; then
      msg_info "  Set BORG_REPOSITORY to a remote path (e.g., ssh://user@host/path)"
    fi
    msg_info "Then run 'fc fc-sync backup' to back up directly to remote."
    return 0
  fi

  local rclone_cmd=${RCLONE_CMD:-rclone}

  validate_remote_config

  local local_archive_path
  local_archive_path=$(backend_get_archive_path)

  if [ ! -f "$local_archive_path" ]; then
    die "Local backup not found at: $local_archive_path. Run 'fc fc-sync backup' first."
  fi

  local remote_dest="$RCLONE_REMOTE:$RCLONE_REMOTE_PATH/"

  msg_info "Uploading backup to remote storage..."
  msg_info "  Source: $local_archive_path"
  msg_info "  Destination: $remote_dest"

  if "$rclone_cmd" copy "$local_archive_path" "$remote_dest" --progress; then
    msg_success "Backup uploaded successfully to $remote_dest"
  else
    die "Failed to upload backup to remote storage."
  fi
}

do_pull() {
  # Check if backend handles remote natively
  if backend_handles_remote; then
    msg_info "Backend '$(backend_get_name)' has native remote support."
    echo ""
    msg_info "Configure your remote destination in the backend-specific settings,"
    msg_info "then run 'fc fc-sync restore' to restore directly from remote."
    return 0
  fi

  local rclone_cmd=${RCLONE_CMD:-rclone}

  validate_remote_config

  local local_dest_dir="$BACKUP_DEST_DIR"
  local remote_src="$RCLONE_REMOTE:$RCLONE_REMOTE_PATH/$BACKUP_ARCHIVE_NAME"

  msg_info "Downloading backup from remote storage..."
  msg_info "  Source: $remote_src"
  msg_info "  Destination: $local_dest_dir/"

  if "$rclone_cmd" copy "$remote_src" "$local_dest_dir/" --progress; then
    local local_archive_path="$local_dest_dir/$BACKUP_ARCHIVE_NAME"
    if [ -f "$local_archive_path" ]; then
      msg_success "Backup downloaded to: $local_archive_path"
    else
      die "Download appeared to succeed but file not found at: $local_archive_path"
    fi
  else
    die "Failed to download backup from remote storage."
  fi
}

do_list_remote() {
  # Check if backend handles remote natively
  if backend_handles_remote; then
    msg_info "Backend '$(backend_get_name)' has native remote support."
    echo ""
    if [ "$BACKUP_BACKEND" = "restic" ]; then
      msg_info "List snapshots with: restic -r \$RESTIC_REPOSITORY snapshots"
    elif [ "$BACKUP_BACKEND" = "borg" ]; then
      msg_info "List archives with: borg list \$BORG_REPOSITORY"
    fi
    return 0
  fi

  local rclone_cmd=${RCLONE_CMD:-rclone}

  validate_remote_config

  local remote_path="$RCLONE_REMOTE:$RCLONE_REMOTE_PATH/"

  msg_info "Listing backups at: $remote_path"
  echo ""

  if ! "$rclone_cmd" ls "$remote_path" 2>/dev/null; then
    msg_warning "No backups found or unable to list remote path."
    msg_info "Ensure the remote path exists and rclone is configured correctly."
    return 1
  fi
}

# --- Main Dispatcher ---
main() {
  # Parse global flags
  local no_confirm=false
  while [[ "${1:-}" == --* ]]; do
    case "$1" in
      --no-confirm)
        no_confirm=true
        shift
        ;;
      --help)
        usage
        ;;
      *)
        break
        ;;
    esac
  done

  if [ -z "${1:-}" ]; then
    usage
  fi

  local subcommand="$1"
  shift

  # Load the backend for all commands except setup and help
  if [ "$subcommand" != "setup" ]; then
    load_backend
  fi

  case "$subcommand" in
    setup)
      do_setup
      ;;
    backup)
      backend_check_dependencies
      backend_validate_config
      if [ "$no_confirm" = false ]; then
        prompt_for_confirmation "Ready to begin backup using $(backend_get_name) backend."
      fi
      backend_do_backup
      ;;
    restore)
      backend_check_dependencies
      backend_validate_config
      if [ "$no_confirm" = false ]; then
        prompt_for_confirmation "Ready to restore from backup. This may overwrite existing files."
      fi
      backend_do_restore
      ;;
    push)
      check_remote_dependencies
      if [ "$no_confirm" = false ]; then
        prompt_for_confirmation "Ready to upload backup to remote storage."
      fi
      do_push
      ;;
    pull)
      check_remote_dependencies
      if [ "$no_confirm" = false ]; then
        prompt_for_confirmation "Ready to download backup from remote storage."
      fi
      do_pull
      ;;
    list-remote)
      check_remote_dependencies
      do_list_remote
      ;;
    *)
      die "Unknown subcommand: $subcommand. Run 'fc fc-sync --help' for available subcommands."
      ;;
  esac
}

main "$@"
