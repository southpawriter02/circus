#!/usr/bin/env bash

# ==============================================================================
#
# FILE:         sync
#
# DESCRIPTION:  This script handles the encrypted backup and restoration of
#               system state, including application settings, user data, and a
#               list of installed packages.
#
# ==============================================================================

# --- Initialization ---------------------------------------------------------
# Source the centralized initialization script to set up the environment.
source "$(dirname "${BASH_SOURCE[0]}")/../init.sh"

# --- Configuration Loading ---

readonly SYNC_CONFIG_FILE="$HOME/.config/circus/sync.conf"
readonly SYNC_CONFIG_TEMPLATE="$DOTFILES_ROOT/lib/templates/sync.conf.template"

# Default values (can be overridden by config file)
BACKUP_DEST_DIR="${BACKUP_DEST_DIR:-$HOME}"
BACKUP_ARCHIVE_NAME="${BACKUP_ARCHIVE_NAME:-circus_backup.tar.gz.gpg}"
GPG_RECIPIENT_ID=""
BACKUP_TARGETS=()

# Remote storage defaults
RCLONE_REMOTE=""
RCLONE_REMOTE_PATH="circus-backups"

# Load user configuration if it exists
if [ -f "$SYNC_CONFIG_FILE" ]; then
  # Security check: warn if file is world-writable (check "other" bits)
  perms=$(stat -f '%Lp' "$SYNC_CONFIG_FILE" 2>/dev/null || echo "000")
  other_perms=$((perms % 10))  # Get the last digit (other permissions)
  if [ "$other_perms" -ge 2 ] 2>/dev/null; then
    msg_warning "Config file $SYNC_CONFIG_FILE is world-writable. Consider: chmod 600 $SYNC_CONFIG_FILE"
  fi
  # shellcheck source=/dev/null
  source "$SYNC_CONFIG_FILE"
fi

# Validate required configuration
validate_config() {
  if [ -z "$GPG_RECIPIENT_ID" ]; then
    msg_error "GPG_RECIPIENT_ID is not configured."
    echo ""
    msg_info "To configure fc-sync:"
    msg_info "  1. Run setup:     fc fc-sync setup"
    msg_info "  2. Edit config:   \$EDITOR $SYNC_CONFIG_FILE"
    msg_info "  3. Set your GPG key ID (find with: gpg --list-keys --keyid-format LONG)"
    die "Configuration required. See instructions above."
  fi

  if [ ${#BACKUP_TARGETS[@]} -eq 0 ]; then
    die "BACKUP_TARGETS is empty. Configure at least one path in $SYNC_CONFIG_FILE"
  fi
}

# Validate remote storage configuration
validate_remote_config() {
  local rclone_cmd=${RCLONE_CMD:-rclone}

  if [ -z "$RCLONE_REMOTE" ]; then
    msg_error "RCLONE_REMOTE is not configured."
    echo ""
    msg_info "To configure remote storage:"
    msg_info "  1. Configure rclone: rclone config"
    msg_info "  2. Edit: \$EDITOR $SYNC_CONFIG_FILE"
    msg_info "  3. Set RCLONE_REMOTE to your remote name"
    die "Remote storage not configured."
  fi

  # Verify rclone remote exists
  if ! "$rclone_cmd" listremotes 2>/dev/null | grep -q "^${RCLONE_REMOTE}:$"; then
    msg_error "rclone remote '$RCLONE_REMOTE' not found."
    echo ""
    msg_info "Available remotes:"
    "$rclone_cmd" listremotes 2>/dev/null || echo "  (none configured)"
    echo ""
    msg_info "Configure a new remote with: rclone config"
    die "Invalid rclone remote: $RCLONE_REMOTE"
  fi
}

# --- Usage Information ---
usage() {
  msg_info "Usage: fc fc-sync [options] <subcommand>"
  echo ""
  msg_info "Manages the encrypted backup and restoration of system state."
  echo ""
  msg_info "Subcommands:"
  echo "  setup       - Create configuration file from template."
  echo "  backup      - Backs up and encrypts critical data."
  echo "  restore     - Decrypts and restores data from an encrypted backup."
  echo "  push        - Upload local backup to configured remote storage."
  echo "  pull        - Download backup from remote storage."
  echo "  list-remote - List available backups on remote storage."
  echo ""
  msg_info "Options:"
  echo "  --no-confirm  - Skip confirmation prompts (for automated/scheduled use)."
  echo ""
  msg_info "Configuration: $SYNC_CONFIG_FILE"
  msg_info "Remote storage requires rclone: https://rclone.org/"
  exit 0
}

# --- Command Logic ---

do_setup() {
  local config_dir="$HOME/.config/circus"

  if [ -f "$SYNC_CONFIG_FILE" ]; then
    msg_info "Configuration file already exists: $SYNC_CONFIG_FILE"
    echo ""
    msg_info "Edit it with: \$EDITOR $SYNC_CONFIG_FILE"
    return 0
  fi

  if [ ! -f "$SYNC_CONFIG_TEMPLATE" ]; then
    die "Configuration template not found: $SYNC_CONFIG_TEMPLATE"
  fi

  msg_info "Creating configuration directory..."
  mkdir -p "$config_dir"

  msg_info "Copying configuration template..."
  cp "$SYNC_CONFIG_TEMPLATE" "$SYNC_CONFIG_FILE"
  chmod 600 "$SYNC_CONFIG_FILE"

  msg_success "Configuration file created: $SYNC_CONFIG_FILE"
  echo ""
  msg_info "Next steps:"
  msg_info "  1. Edit the config: \$EDITOR $SYNC_CONFIG_FILE"
  msg_info "  2. Set GPG_RECIPIENT_ID to your GPG key ID"
  msg_info "  3. Customize BACKUP_TARGETS as needed"
  echo ""
  msg_info "Find your GPG key ID with: gpg --list-keys --keyid-format LONG"
}

do_backup() {
  local brew_cmd=${BREW_CMD:-brew}
  local tar_cmd=${TAR_CMD:-tar}
  local mktemp_cmd=${MKTEMP_CMD:-mktemp}
  local gpg_cmd=${GPG_CMD:-gpg}

  validate_config

  local temp_backup_dir
  temp_backup_dir=$($mktemp_cmd -d)
  msg_info "Created temporary backup directory: $temp_backup_dir"

  msg_info "Creating application inventory..."
  # Only run brew if it's available (it's optional for basic backup)
  if command -v "$brew_cmd" >/dev/null 2>&1; then
    "$brew_cmd" bundle dump --force --file="$temp_backup_dir/Brewfile.dump"
  else
    msg_warning "Homebrew not found, skipping application inventory."
  fi

  msg_info "Backing up critical files..."
  for target in "${BACKUP_TARGETS[@]}"; do
    local expanded_target
    eval expanded_target="$target"
    if [ -e "$expanded_target" ]; then
      rsync -a "$expanded_target" "$temp_backup_dir/"
    fi
  done

  msg_info "Creating and encrypting backup archive..."
  local final_archive_path="$BACKUP_DEST_DIR/$BACKUP_ARCHIVE_NAME"
  "$tar_cmd" -czf - -C "$temp_backup_dir" . | "$gpg_cmd" -e -r "$GPG_RECIPIENT_ID" -o "$final_archive_path"

  msg_info "Cleaning up temporary files..."
  rm -rf "$temp_backup_dir"

  msg_success "Encrypted backup created at: $final_archive_path"
}

do_restore() {
  local brew_cmd=${BREW_CMD:-brew}
  local gpg_cmd=${GPG_CMD:-gpg}

  validate_config

  local encrypted_archive_path="$BACKUP_DEST_DIR/$BACKUP_ARCHIVE_NAME"

  if [ ! -f "$encrypted_archive_path" ]; then
    die "Encrypted backup archive not found at: $encrypted_archive_path"
  fi

  local temp_restore_dir
  temp_restore_dir=$(mktemp -d)
  msg_info "Decrypting backup... You may be prompted for your GPG passphrase."

  # The `set -e` option in helpers.sh will cause the script to exit if gpg fails.
  # The global error trap will provide a detailed error message.
  "$gpg_cmd" -d "$encrypted_archive_path" | tar -xzf - -C "$temp_restore_dir"
  msg_success "Decryption and extraction successful."

  msg_info "Restoring applications from inventory..."
  # Only restore apps if brew is available
  if command -v "$brew_cmd" >/dev/null 2>&1; then
    "$brew_cmd" bundle install --file="$temp_restore_dir/Brewfile.dump"
  else
    msg_warning "Homebrew not found, skipping application restoration."
  fi

  msg_info "Restoring critical files..."
  for target in "${BACKUP_TARGETS[@]}"; do
    local backup_source="$temp_restore_dir/$(basename "$target")"
    local restore_dest
    eval restore_dest="$target"
    if [ -e "$backup_source" ]; then
      rsync -a "$backup_source" "$(dirname "$restore_dest")"
    fi
  done

  msg_info "Cleaning up temporary files..."
  rm -rf "$temp_restore_dir"

  msg_success "System restoration complete."
}

# --- Remote Storage Commands ---

do_push() {
  local rclone_cmd=${RCLONE_CMD:-rclone}

  validate_remote_config

  local local_archive_path="$BACKUP_DEST_DIR/$BACKUP_ARCHIVE_NAME"

  if [ ! -f "$local_archive_path" ]; then
    die "Local backup not found at: $local_archive_path. Run 'fc sync backup' first."
  fi

  local remote_dest="$RCLONE_REMOTE:$RCLONE_REMOTE_PATH/"

  msg_info "Uploading backup to remote storage..."
  msg_info "  Source: $local_archive_path"
  msg_info "  Destination: $remote_dest"

  if "$rclone_cmd" copy "$local_archive_path" "$remote_dest" --progress; then
    msg_success "Backup uploaded successfully to $remote_dest"
  else
    die "Failed to upload backup to remote storage."
  fi
}

do_pull() {
  local rclone_cmd=${RCLONE_CMD:-rclone}

  validate_remote_config

  local local_dest_dir="$BACKUP_DEST_DIR"
  local remote_src="$RCLONE_REMOTE:$RCLONE_REMOTE_PATH/$BACKUP_ARCHIVE_NAME"

  msg_info "Downloading backup from remote storage..."
  msg_info "  Source: $remote_src"
  msg_info "  Destination: $local_dest_dir/"

  if "$rclone_cmd" copy "$remote_src" "$local_dest_dir/" --progress; then
    local local_archive_path="$local_dest_dir/$BACKUP_ARCHIVE_NAME"
    if [ -f "$local_archive_path" ]; then
      msg_success "Backup downloaded to: $local_archive_path"
    else
      die "Download appeared to succeed but file not found at: $local_archive_path"
    fi
  else
    die "Failed to download backup from remote storage."
  fi
}

do_list_remote() {
  local rclone_cmd=${RCLONE_CMD:-rclone}

  validate_remote_config

  local remote_path="$RCLONE_REMOTE:$RCLONE_REMOTE_PATH/"

  msg_info "Listing backups at: $remote_path"
  echo ""

  if ! "$rclone_cmd" ls "$remote_path" 2>/dev/null; then
    msg_warning "No backups found or unable to list remote path."
    msg_info "Ensure the remote path exists and rclone is configured correctly."
    return 1
  fi
}

# --- Dependency Checks ---
check_dependencies() {
  local gpg_cmd=${GPG_CMD:-gpg}
  local rsync_cmd=${RSYNC_CMD:-rsync}

  if ! command -v "$gpg_cmd" >/dev/null 2>&1; then
    die "GPG is not installed. Please run 'brew install gpg-suite'."
  fi

  if ! command -v "$rsync_cmd" >/dev/null 2>&1; then
    die "This command requires 'rsync'. Please install it first."
  fi
}

check_remote_dependencies() {
  local rclone_cmd=${RCLONE_CMD:-rclone}

  if ! command -v "$rclone_cmd" >/dev/null 2>&1; then
    msg_error "rclone is not installed."
    echo ""
    msg_info "Install rclone with: brew install rclone"
    msg_info "Then configure a remote with: rclone config"
    die "rclone required for remote storage operations."
  fi
}

# --- Main Dispatcher ---
main() {
  # Parse global flags
  local no_confirm=false
  while [[ "${1:-}" == --* ]]; do
    case "$1" in
      --no-confirm)
        no_confirm=true
        shift
        ;;
      --help)
        usage
        ;;
      *)
        break
        ;;
    esac
  done

  if [ -z "${1:-}" ]; then
    usage
  fi

  local subcommand="$1"
  shift

  case "$subcommand" in
    setup)
      do_setup
      ;;
    backup)
      check_dependencies
      if [ "$no_confirm" = false ]; then
        prompt_for_confirmation "Ready to begin the encrypted backup process."
      fi
      do_backup
      ;;
    restore)
      check_dependencies
      if [ "$no_confirm" = false ]; then
        prompt_for_confirmation "Ready to restore from an encrypted backup. This may overwrite existing files."
      fi
      do_restore
      ;;
    push)
      check_remote_dependencies
      if [ "$no_confirm" = false ]; then
        prompt_for_confirmation "Ready to upload backup to remote storage."
      fi
      do_push
      ;;
    pull)
      check_remote_dependencies
      if [ "$no_confirm" = false ]; then
        prompt_for_confirmation "Ready to download backup from remote storage."
      fi
      do_pull
      ;;
    list-remote)
      check_remote_dependencies
      do_list_remote
      ;;
    *)
      die "Unknown subcommand: $subcommand. Run 'fc sync --help' for available subcommands."
      ;;
  esac
}

main "$@"
