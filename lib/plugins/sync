#!/usr/bin/env bash

# ==============================================================================
#
# FILE:         sync
#
# DESCRIPTION:  This script handles the encrypted backup and restoration of
#               system state, including application settings, user data, and a
#               list of installed packages.
#
# USAGE:        fc sync <subcommand>
#
# ==============================================================================

# --- Configuration ---

# Define the destination directory for your encrypted backup archive.
readonly BACKUP_DEST_DIR="$HOME"

# Define the name for the encrypted backup archive.
readonly BACKUP_ARCHIVE_NAME="circus_backup.tar.gz.gpg"

# Define the GPG Key ID of the recipient who can decrypt the backup.
# You can find this by running `gpg --list-keys`.
readonly GPG_RECIPIENT_ID="YOUR_GPG_KEY_ID_HERE"

# Define the list of files and directories to back up.
readonly BACKUP_TARGETS=(
  "$HOME/.ssh"
  "$HOME/.gnupg"
  "$HOME/Documents"
  # Add other directories like "$HOME/Projects" here.
)

# --- Setup & Helpers ---

set -e
# Source the main helper library. The path is relative to the script location.
source "$(dirname "${BASH_SOURCE[0]}")/../helpers.sh"

# --- Usage Information ---

usage() {
  echo "Usage: fc sync <subcommand>"
  echo ""
  echo "Manages the encrypted backup and restoration of system state."
  echo ""
  echo "Subcommands:"
  echo "  backup    - Backs up and encrypts critical data."
  echo "  restore   - Decrypts and restores data from an encrypted backup."
  exit 1
}

# --- Command Logic ---

do_backup() {
  if [ "$GPG_RECIPIENT_ID" == "YOUR_GPG_KEY_ID_HERE" ]; then
    msg_error "Please configure your GPG_RECIPIENT_ID at the top of this script."
    return 1
  fi

  local temp_backup_dir
  temp_backup_dir=$(mktemp -d)
  msg_info "Created temporary backup directory: $temp_backup_dir"

  msg_info "Creating application inventory..."
  brew bundle dump --force --file="$temp_backup_dir/Brewfile.dump"

  msg_info "Backing up critical files..."
  for target in "${BACKUP_TARGETS[@]}"; do
    local expanded_target
    eval expanded_target="$target"
    if [ -e "$expanded_target" ]; then
      rsync -a "$expanded_target" "$temp_backup_dir/"
    fi
  done

  msg_info "Creating and encrypting backup archive..."
  local final_archive_path="$BACKUP_DEST_DIR/$BACKUP_ARCHIVE_NAME"
  tar -czf - -C "$temp_backup_dir" . | gpg -e -r "$GPG_RECIPIENT_ID" -o "$final_archive_path"

  msg_info "Cleaning up temporary files..."
  rm -rf "$temp_backup_dir"

  msg_success "Encrypted backup created at: $final_archive_path"
}

do_restore() {
  local encrypted_archive_path="$BACKUP_DEST_DIR/$BACKUP_ARCHIVE_NAME"
  if [ ! -f "$encrypted_archive_path" ]; then
    msg_error "Encrypted backup archive not found at: $encrypted_archive_path"
    return 1
  fi

  local temp_restore_dir
  temp_restore_dir=$(mktemp -d)
  msg_info "Decrypting backup... You may be prompted for your GPG passphrase."
  if ! gpg -d "$encrypted_archive_path" | tar -xzf - -C "$temp_restore_dir"; then
    msg_error "Decryption failed. Aborting restore."
    rm -rf "$temp_restore_dir"
    return 1
  fi

  msg_info "Restoring applications from inventory..."
  brew bundle install --file="$temp_restore_dir/Brewfile.dump"

  msg_info "Restoring critical files..."
  for target in "${BACKUP_TARGETS[@]}"; do
    local backup_source="$temp_restore_dir/$(basename "$target")"
    local restore_dest
    eval restore_dest="$target"
    if [ -e "$backup_source" ]; then
      rsync -a "$backup_source" "$(dirname "$restore_dest")"
    fi
  done

  msg_info "Cleaning up temporary files..."
  rm -rf "$temp_restore_dir"

  msg_success "System restoration complete."
}

# --- Main Dispatcher ---

main() {
  if ! command -v gpg >/dev/null 2>&1; then
    msg_error "GPG is not installed. Please install it via Homebrew ('brew install gpg-suite')."
    return 1
  fi

  if [ -z "$1" ]; then
    usage
  fi

  local subcommand="$1"
  shift

  case "$subcommand" in
    backup)
      prompt_for_confirmation "Ready to begin the encrypted backup process."
      do_backup
      ;;
    restore)
      prompt_for_confirmation "Ready to restore from an encrypted backup. This may overwrite existing files."
      do_restore
      ;;
    *)
      msg_error "Unknown subcommand: $subcommand"
      usage
      ;;
  esac
}

main "$@"
