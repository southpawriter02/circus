#!/usr/bin/env bash

# ==============================================================================
#
# FILE:         update
#
# DESCRIPTION:  Unified system update command. Updates macOS, Homebrew packages,
#               Mac App Store apps, and the dotfiles repository. Handles
#               dependency changes, runs migrations, and supports various flags.
#
# ==============================================================================

# --- Initialization ---------------------------------------------------------
source "$(dirname "${BASH_SOURCE[0]}")/../init.sh"

# --- Global Flags -----------------------------------------------------------
FLAG_CHECK=false
FLAG_DRY_RUN=false
FLAG_SKIP_MIGRATIONS=false
FLAG_UPDATE_OS=false
FLAG_UPDATE_PACKAGES=false
FLAG_UPDATE_SELF=false
FLAG_UPDATE_ALL=true

# --- Help and Usage ---------------------------------------------------------
usage() {
  msg_info "Usage: fc update [options]"
  echo ""
  msg_info "Updates macOS, Homebrew packages, and the dotfiles repository."
  echo ""
  msg_info "Update Targets:"
  echo "  --all               Update everything (default)"
  echo "  --os                Update macOS only"
  echo "  --packages          Update Homebrew and Mac App Store only"
  echo "  --self              Update dotfiles repository only"
  echo ""
  msg_info "Options:"
  echo "  --help              Show this help message"
  echo "  --version           Show the current installed version"
  echo "  --check             Check for dotfiles updates without applying"
  echo "  --dry-run           Show what would be done without making changes"
  echo "  --skip-migrations   Skip running migration scripts (for --self)"
  echo ""
  msg_info "Examples:"
  echo "  fc update              # Update everything"
  echo "  fc update --packages   # Update only Homebrew/MAS"
  echo "  fc update --os         # Update only macOS"
  echo "  fc update --self       # Update only dotfiles"
  echo "  fc update --dry-run    # Preview all updates"
  echo ""
  exit 0
}

# --- Version Display --------------------------------------------------------
show_version() {
  local version
  version=$(get_current_version)
  echo "Dotfiles Flying Circus v$version"
  exit 0
}

# --- Check for Updates ------------------------------------------------------
check_for_updates() {
  local current_version
  current_version=$(get_current_version)

  msg_info "Checking for updates..."

  cd "$DOTFILES_ROOT" || die "Could not navigate to the dotfiles directory: $DOTFILES_ROOT"

  # Fetch latest from remote
  if ! git fetch -q 2>/dev/null; then
    msg_warning "Could not fetch from remote. Check your network connection."
    exit 1
  fi

  local local_head remote_head
  local_head=$(git rev-parse HEAD)
  remote_head=$(git rev-parse '@{u}' 2>/dev/null || echo "")

  if [ -z "$remote_head" ]; then
    msg_warning "No upstream branch configured."
    exit 1
  fi

  if [ "$local_head" = "$remote_head" ]; then
    msg_success "You are up-to-date! (v$current_version)"
    exit 0
  fi

  # Count commits behind
  local commits_behind
  commits_behind=$(git rev-list --count HEAD..@{u} 2>/dev/null || echo "0")

  # Try to get remote version (fetch the .version file content)
  local remote_version
  remote_version=$(git show @{u}:.version 2>/dev/null | tr -d '[:space:]' || echo "unknown")

  msg_warning "Updates available!"
  echo ""
  echo "  Current version: v$current_version"
  echo "  Available version: v$remote_version"
  echo "  Commits behind: $commits_behind"
  echo ""
  msg_info "Run 'fc update' to install updates."
  exit 0
}

# --- Run Migrations ---------------------------------------------------------
run_migrations() {
  local old_version="$1"
  local new_version="$2"
  local migrations_dir="$DOTFILES_ROOT/migrations"

  # Skip if versions are the same
  if [ "$old_version" = "$new_version" ]; then
    msg_debug "No version change, skipping migrations."
    return 0
  fi

  # Skip if no migrations directory
  if [ ! -d "$migrations_dir" ]; then
    msg_debug "No migrations directory found."
    return 0
  fi

  msg_info "Checking for migrations..."

  local migrations_found=false

  # Find and run applicable migrations
  for migration in "$migrations_dir"/v*_to_v*.sh; do
    [ -f "$migration" ] || continue

    local filename
    filename=$(basename "$migration" .sh)

    # Parse version range from filename (e.g., "v1.0.0_to_v1.1.0")
    local from_ver to_ver
    from_ver=${filename%%_to_*}
    to_ver=${filename##*_to_}
    from_ver=${from_ver#v}
    to_ver=${to_ver#v}

    # Check if this migration applies to our upgrade path
    if version_in_range "$from_ver" "$to_ver" "$old_version" "$new_version"; then
      migrations_found=true

      if [ "$FLAG_DRY_RUN" = true ]; then
        msg_info "[DRY-RUN] Would run migration: $filename"
      else
        msg_info "Running migration: $filename"
        # shellcheck source=/dev/null
        if ! source "$migration"; then
          msg_error "Migration $filename failed!"
          return 1
        fi
        msg_success "Migration $filename completed."
      fi
    fi
  done

  if [ "$migrations_found" = false ]; then
    msg_info "No migrations needed for this update."
  fi

  return 0
}

# --- Handle Dependency Changes ----------------------------------------------
handle_dependencies() {
  local old_head="$1"
  local new_head="$2"

  local role_file="$HOME/.circus/role"
  if [ ! -f "$role_file" ]; then
    msg_debug "No role file found, skipping dependency check."
    return 0
  fi

  local current_role
  current_role=$(cat "$role_file")
  local brewfile_path="roles/$current_role/Brewfile"

  if [ ! -f "$DOTFILES_ROOT/$brewfile_path" ]; then
    msg_debug "No Brewfile found for role '$current_role'."
    return 0
  fi

  # Check if the Brewfile was modified in the commits we just pulled
  if git diff --quiet "$old_head" "$new_head" -- "$brewfile_path" 2>/dev/null; then
    msg_info "No dependency changes detected for role '$current_role'."
  else
    msg_warning "Dependencies for role '$current_role' have changed."

    if [ "$FLAG_DRY_RUN" = true ]; then
      msg_info "[DRY-RUN] Would run: brew bundle install --file=$DOTFILES_ROOT/$brewfile_path"
    else
      msg_info "Running 'brew bundle' to install/update dependencies..."
      if ! brew bundle install --file="$DOTFILES_ROOT/$brewfile_path"; then
        msg_warning "Some dependencies may have failed to install."
      else
        msg_success "Dependencies are now up-to-date."
      fi
    fi
  fi
}

# --- Update Homebrew Packages -----------------------------------------------
update_packages() {
  local brew_cmd=${BREW_CMD:-brew}

  if ! command -v "$brew_cmd" >/dev/null 2>&1; then
    msg_error "Homebrew is not installed. Skipping package updates."
    return 1
  fi

  echo ""
  msg_info "=== Updating Homebrew Packages ==="
  echo ""

  if [ "$FLAG_DRY_RUN" = true ]; then
    msg_info "[DRY-RUN] Would run: brew update"
    msg_info "[DRY-RUN] Checking for outdated packages..."
    echo ""
    "$brew_cmd" outdated 2>/dev/null || true
    echo ""
    msg_info "[DRY-RUN] Would run: brew upgrade"
    msg_info "[DRY-RUN] Would run: brew upgrade --cask"
    return 0
  fi

  # Update Homebrew itself
  msg_info "Updating Homebrew..."
  if ! "$brew_cmd" update; then
    msg_warning "Homebrew update encountered issues."
  fi

  # Check for outdated packages
  local outdated
  outdated=$("$brew_cmd" outdated 2>/dev/null || true)

  if [ -z "$outdated" ]; then
    msg_success "All Homebrew formulae are up to date."
  else
    msg_info "Outdated formulae:"
    echo "$outdated"
    echo ""
    msg_info "Upgrading formulae..."
    if "$brew_cmd" upgrade; then
      msg_success "Homebrew formulae updated."
    else
      msg_warning "Some formulae may have failed to upgrade."
    fi
  fi

  # Update casks
  echo ""
  msg_info "Checking for cask updates..."
  local outdated_casks
  outdated_casks=$("$brew_cmd" outdated --cask 2>/dev/null || true)

  if [ -z "$outdated_casks" ]; then
    msg_success "All Homebrew casks are up to date."
  else
    msg_info "Outdated casks:"
    echo "$outdated_casks"
    echo ""
    msg_info "Upgrading casks..."
    if "$brew_cmd" upgrade --cask; then
      msg_success "Homebrew casks updated."
    else
      msg_warning "Some casks may have failed to upgrade."
    fi
  fi

  # Update Mac App Store apps if mas is available
  local mas_cmd=${MAS_CMD:-mas}
  if command -v "$mas_cmd" >/dev/null 2>&1; then
    echo ""
    msg_info "Checking for Mac App Store updates..."
    local outdated_mas
    outdated_mas=$("$mas_cmd" outdated 2>/dev/null || true)

    if [ -z "$outdated_mas" ]; then
      msg_success "All Mac App Store apps are up to date."
    else
      msg_info "Outdated apps:"
      echo "$outdated_mas"
      echo ""
      msg_info "Upgrading Mac App Store apps..."
      if "$mas_cmd" upgrade; then
        msg_success "Mac App Store apps updated."
      else
        msg_warning "Some apps may have failed to upgrade."
      fi
    fi
  else
    msg_info "mas-cli not installed. Skipping Mac App Store updates."
    msg_info "Install with: brew install mas"
  fi

  echo ""
  msg_success "Package updates complete."
}

# --- Update macOS -----------------------------------------------------------
update_macos() {
  echo ""
  msg_info "=== Checking for macOS Updates ==="
  echo ""

  if [ "$FLAG_DRY_RUN" = true ]; then
    msg_info "[DRY-RUN] Would run: softwareupdate -l"
    echo ""
    softwareupdate -l 2>&1 || true
    echo ""
    msg_info "[DRY-RUN] Would run: softwareupdate -ia (if updates available)"
    return 0
  fi

  # List available updates
  msg_info "Checking for available updates..."
  local updates
  updates=$(softwareupdate -l 2>&1)

  if echo "$updates" | grep -q "No new software available"; then
    msg_success "macOS is up to date."
    return 0
  fi

  echo ""
  echo "$updates"
  echo ""

  msg_warning "macOS updates are available."
  msg_info "Note: Some updates may require a restart."
  echo ""

  prompt_for_confirmation "Would you like to install available macOS updates?"

  msg_info "Installing macOS updates (this may take a while)..."
  if sudo softwareupdate -ia --verbose; then
    msg_success "macOS updates installed."
    msg_info "You may need to restart your computer for changes to take effect."
  else
    msg_warning "Some updates may have failed to install."
  fi
}

# --- Update Self (Dotfiles Repository) --------------------------------------
update_self() {
  echo ""
  msg_info "=== Updating Dotfiles Repository ==="
  echo ""

  # Validate dependencies
  if ! command -v git >/dev/null 2>&1; then
    msg_error "Git is not installed. Skipping dotfiles update."
    return 1
  fi

  cd "$DOTFILES_ROOT" || die "Could not navigate to the dotfiles directory: $DOTFILES_ROOT"

  # Record current version before update
  local old_version
  old_version=$(get_current_version)

  # --- Stash Local Changes (if any) ---
  msg_info "Checking for local changes..."
  local stashed=false

  # Check for both staged and unstaged changes
  if ! git diff-index --quiet HEAD -- 2>/dev/null || ! git diff-files --quiet 2>/dev/null; then
    msg_warning "You have uncommitted changes in your local repository."

    if [ "$FLAG_DRY_RUN" = true ]; then
      msg_info "[DRY-RUN] Would stash local changes."
    else
      prompt_for_confirmation "Would you like to stash them before updating?"
      msg_info "Stashing local changes (including untracked files)..."
      git stash push --include-untracked
      stashed=true
      msg_success "Local changes have been stashed."
    fi
  fi

  # --- Pull Latest Version ---
  local old_head new_head
  old_head=$(git rev-parse HEAD)

  if [ "$FLAG_DRY_RUN" = true ]; then
    msg_info "[DRY-RUN] Would run: git pull --rebase"
    # For dry-run, simulate the new head
    new_head=$(git rev-parse '@{u}' 2>/dev/null || echo "$old_head")
  else
    msg_info "Pulling the latest version from the remote repository..."
    if ! git pull --rebase; then
      msg_error "The update failed. Please resolve any conflicts and then run 'git pull' manually."
      # If the pull failed, try to restore the stash anyway
      if [ "$stashed" = true ]; then
        git stash pop
      fi
      return 1
    fi
    new_head=$(git rev-parse HEAD)
    msg_success "Code update successful!"
  fi

  # Get new version after pull
  local new_version
  if [ "$FLAG_DRY_RUN" = true ]; then
    new_version=$(git show @{u}:.version 2>/dev/null | tr -d '[:space:]' || echo "$old_version")
  else
    new_version=$(get_current_version)
  fi

  # --- Run Migrations ---
  if [ "$FLAG_SKIP_MIGRATIONS" = false ]; then
    run_migrations "$old_version" "$new_version"
  else
    msg_info "Skipping migrations (--skip-migrations flag set)."
  fi

  # --- Handle Dependency Changes ---
  handle_dependencies "$old_head" "$new_head"

  # --- Restore Stashed Changes ---
  if [ "$stashed" = true ]; then
    if [ "$FLAG_DRY_RUN" = true ]; then
      msg_info "[DRY-RUN] Would restore stashed changes."
    else
      msg_info "Re-applying your stashed local changes..."
      git stash pop
      msg_success "Your local changes have been restored."
    fi
  fi

  # --- Summary ---
  echo ""
  if [ "$FLAG_DRY_RUN" = true ]; then
    msg_success "[DRY-RUN] Dotfiles update simulation complete."
    echo "  Would update from: v$old_version → v$new_version"
  else
    if [ "$old_version" != "$new_version" ]; then
      msg_success "The Dotfiles Flying Circus has been updated!"
      echo "  Updated from: v$old_version → v$new_version"
    else
      msg_success "The Dotfiles Flying Circus is now up-to-date. (v$new_version)"
    fi
  fi
}

# --- Main Logic -------------------------------------------------------------
main() {
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --help)
        usage
        ;;
      --version)
        show_version
        ;;
      --check)
        FLAG_CHECK=true
        shift
        ;;
      --dry-run)
        FLAG_DRY_RUN=true
        shift
        ;;
      --skip-migrations)
        FLAG_SKIP_MIGRATIONS=true
        shift
        ;;
      --all)
        FLAG_UPDATE_ALL=true
        shift
        ;;
      --os)
        FLAG_UPDATE_OS=true
        FLAG_UPDATE_ALL=false
        shift
        ;;
      --packages)
        FLAG_UPDATE_PACKAGES=true
        FLAG_UPDATE_ALL=false
        shift
        ;;
      --self)
        FLAG_UPDATE_SELF=true
        FLAG_UPDATE_ALL=false
        shift
        ;;
      *)
        die "Unknown option: $1. Use --help for usage information."
        ;;
    esac
  done

  # Handle --check flag (only applies to dotfiles repo)
  if [ "$FLAG_CHECK" = true ]; then
    check_for_updates
  fi

  # Display header
  if [ "$FLAG_DRY_RUN" = true ]; then
    msg_info "[DRY-RUN] Starting update simulation..."
  else
    msg_info "Starting system update..."
  fi

  # Execute requested updates in order: packages → OS → self
  # Order rationale:
  #   1. Packages first: ensures latest brew/mas before system updates
  #   2. OS second: major system updates may require restart
  #   3. Self last: always get latest dotfiles changes

  if [ "$FLAG_UPDATE_ALL" = true ] || [ "$FLAG_UPDATE_PACKAGES" = true ]; then
    update_packages
  fi

  if [ "$FLAG_UPDATE_ALL" = true ] || [ "$FLAG_UPDATE_OS" = true ]; then
    update_macos
  fi

  if [ "$FLAG_UPDATE_ALL" = true ] || [ "$FLAG_UPDATE_SELF" = true ]; then
    update_self
  fi

  # Final summary
  echo ""
  if [ "$FLAG_DRY_RUN" = true ]; then
    msg_success "[DRY-RUN] Update simulation complete."
  else
    msg_success "System update complete!"
  fi
}

main "$@"
