#!/usr/bin/env bash

# ==============================================================================
#
# FILE:         update
#
# DESCRIPTION:  This command provides a safe and robust way to update the
#               Dotfiles Flying Circus to the latest version. It handles
#               dependency changes, runs migrations, and supports various flags.
#
# ==============================================================================

# --- Initialization ---------------------------------------------------------
source "$(dirname "${BASH_SOURCE[0]}")/../init.sh"

# --- Global Flags -----------------------------------------------------------
FLAG_CHECK=false
FLAG_DRY_RUN=false
FLAG_SKIP_MIGRATIONS=false

# --- Help and Usage ---------------------------------------------------------
usage() {
  msg_info "Usage: fc update [options]"
  echo ""
  msg_info "Safely updates the Dotfiles Flying Circus to the latest version."
  echo ""
  msg_info "Options:"
  echo "  --help              Show this help message"
  echo "  --version           Show the current installed version"
  echo "  --check             Check for updates without applying them"
  echo "  --dry-run           Show what would be done without making changes"
  echo "  --skip-migrations   Skip running migration scripts"
  echo ""
  msg_info "Examples:"
  echo "  fc update           # Update to the latest version"
  echo "  fc update --check   # Check if updates are available"
  echo "  fc update --dry-run # Preview what the update would do"
  echo ""
  exit 0
}

# --- Version Display --------------------------------------------------------
show_version() {
  local version
  version=$(get_current_version)
  echo "Dotfiles Flying Circus v$version"
  exit 0
}

# --- Check for Updates ------------------------------------------------------
check_for_updates() {
  local current_version
  current_version=$(get_current_version)

  msg_info "Checking for updates..."

  cd "$DOTFILES_ROOT" || die "Could not navigate to the dotfiles directory: $DOTFILES_ROOT"

  # Fetch latest from remote
  if ! git fetch -q 2>/dev/null; then
    msg_warning "Could not fetch from remote. Check your network connection."
    exit 1
  fi

  local local_head remote_head
  local_head=$(git rev-parse HEAD)
  remote_head=$(git rev-parse '@{u}' 2>/dev/null || echo "")

  if [ -z "$remote_head" ]; then
    msg_warning "No upstream branch configured."
    exit 1
  fi

  if [ "$local_head" = "$remote_head" ]; then
    msg_success "You are up-to-date! (v$current_version)"
    exit 0
  fi

  # Count commits behind
  local commits_behind
  commits_behind=$(git rev-list --count HEAD..@{u} 2>/dev/null || echo "0")

  # Try to get remote version (fetch the .version file content)
  local remote_version
  remote_version=$(git show @{u}:.version 2>/dev/null | tr -d '[:space:]' || echo "unknown")

  msg_warning "Updates available!"
  echo ""
  echo "  Current version: v$current_version"
  echo "  Available version: v$remote_version"
  echo "  Commits behind: $commits_behind"
  echo ""
  msg_info "Run 'fc update' to install updates."
  exit 0
}

# --- Run Migrations ---------------------------------------------------------
run_migrations() {
  local old_version="$1"
  local new_version="$2"
  local migrations_dir="$DOTFILES_ROOT/migrations"

  # Skip if versions are the same
  if [ "$old_version" = "$new_version" ]; then
    msg_debug "No version change, skipping migrations."
    return 0
  fi

  # Skip if no migrations directory
  if [ ! -d "$migrations_dir" ]; then
    msg_debug "No migrations directory found."
    return 0
  fi

  msg_info "Checking for migrations..."

  local migrations_found=false

  # Find and run applicable migrations
  for migration in "$migrations_dir"/v*_to_v*.sh; do
    [ -f "$migration" ] || continue

    local filename
    filename=$(basename "$migration" .sh)

    # Parse version range from filename (e.g., "v1.0.0_to_v1.1.0")
    local from_ver to_ver
    from_ver=${filename%%_to_*}
    to_ver=${filename##*_to_}
    from_ver=${from_ver#v}
    to_ver=${to_ver#v}

    # Check if this migration applies to our upgrade path
    if version_in_range "$from_ver" "$to_ver" "$old_version" "$new_version"; then
      migrations_found=true

      if [ "$FLAG_DRY_RUN" = true ]; then
        msg_info "[DRY-RUN] Would run migration: $filename"
      else
        msg_info "Running migration: $filename"
        # shellcheck source=/dev/null
        if ! source "$migration"; then
          msg_error "Migration $filename failed!"
          return 1
        fi
        msg_success "Migration $filename completed."
      fi
    fi
  done

  if [ "$migrations_found" = false ]; then
    msg_info "No migrations needed for this update."
  fi

  return 0
}

# --- Handle Dependency Changes ----------------------------------------------
handle_dependencies() {
  local old_head="$1"
  local new_head="$2"

  local role_file="$HOME/.circus/role"
  if [ ! -f "$role_file" ]; then
    msg_debug "No role file found, skipping dependency check."
    return 0
  fi

  local current_role
  current_role=$(cat "$role_file")
  local brewfile_path="roles/$current_role/Brewfile"

  if [ ! -f "$DOTFILES_ROOT/$brewfile_path" ]; then
    msg_debug "No Brewfile found for role '$current_role'."
    return 0
  fi

  # Check if the Brewfile was modified in the commits we just pulled
  if git diff --quiet "$old_head" "$new_head" -- "$brewfile_path" 2>/dev/null; then
    msg_info "No dependency changes detected for role '$current_role'."
  else
    msg_warning "Dependencies for role '$current_role' have changed."

    if [ "$FLAG_DRY_RUN" = true ]; then
      msg_info "[DRY-RUN] Would run: brew bundle install --file=$DOTFILES_ROOT/$brewfile_path"
    else
      msg_info "Running 'brew bundle' to install/update dependencies..."
      if ! brew bundle install --file="$DOTFILES_ROOT/$brewfile_path"; then
        msg_warning "Some dependencies may have failed to install."
      else
        msg_success "Dependencies are now up-to-date."
      fi
    fi
  fi
}

# --- Main Logic -------------------------------------------------------------
main() {
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --help)
        usage
        ;;
      --version)
        show_version
        ;;
      --check)
        FLAG_CHECK=true
        shift
        ;;
      --dry-run)
        FLAG_DRY_RUN=true
        shift
        ;;
      --skip-migrations)
        FLAG_SKIP_MIGRATIONS=true
        shift
        ;;
      *)
        die "Unknown option: $1. Use --help for usage information."
        ;;
    esac
  done

  # Handle --check flag
  if [ "$FLAG_CHECK" = true ]; then
    check_for_updates
  fi

  # Validate dependencies
  if ! command -v git >/dev/null 2>&1; then
    die "This command requires 'git'. Please install it first."
  fi

  if ! command -v brew >/dev/null 2>&1; then
    die "This command requires 'brew'. Please install it first."
  fi

  cd "$DOTFILES_ROOT" || die "Could not navigate to the dotfiles directory: $DOTFILES_ROOT"

  # Record current version before update
  local old_version
  old_version=$(get_current_version)

  if [ "$FLAG_DRY_RUN" = true ]; then
    msg_info "[DRY-RUN] Starting update simulation..."
  else
    msg_info "Starting update..."
  fi

  # --- Stash Local Changes (if any) ---
  msg_info "Checking for local changes..."
  local stashed=false

  # Check for both staged and unstaged changes
  if ! git diff-index --quiet HEAD -- 2>/dev/null || ! git diff-files --quiet 2>/dev/null; then
    msg_warning "You have uncommitted changes in your local repository."

    if [ "$FLAG_DRY_RUN" = true ]; then
      msg_info "[DRY-RUN] Would stash local changes."
    else
      prompt_for_confirmation "Would you like to stash them before updating?"
      msg_info "Stashing local changes (including untracked files)..."
      git stash push --include-untracked
      stashed=true
      msg_success "Local changes have been stashed."
    fi
  fi

  # --- Pull Latest Version ---
  local old_head new_head
  old_head=$(git rev-parse HEAD)

  if [ "$FLAG_DRY_RUN" = true ]; then
    msg_info "[DRY-RUN] Would run: git pull --rebase"
    # For dry-run, simulate the new head
    new_head=$(git rev-parse '@{u}' 2>/dev/null || echo "$old_head")
  else
    msg_info "Pulling the latest version from the remote repository..."
    if ! git pull --rebase; then
      msg_error "The update failed. Please resolve any conflicts and then run 'git pull' manually."
      # If the pull failed, try to restore the stash anyway
      if [ "$stashed" = true ]; then
        git stash pop
      fi
      exit 1
    fi
    new_head=$(git rev-parse HEAD)
    msg_success "Code update successful!"
  fi

  # Get new version after pull
  local new_version
  if [ "$FLAG_DRY_RUN" = true ]; then
    new_version=$(git show @{u}:.version 2>/dev/null | tr -d '[:space:]' || echo "$old_version")
  else
    new_version=$(get_current_version)
  fi

  # --- Run Migrations ---
  if [ "$FLAG_SKIP_MIGRATIONS" = false ]; then
    run_migrations "$old_version" "$new_version"
  else
    msg_info "Skipping migrations (--skip-migrations flag set)."
  fi

  # --- Handle Dependency Changes ---
  handle_dependencies "$old_head" "$new_head"

  # --- Restore Stashed Changes ---
  if [ "$stashed" = true ]; then
    if [ "$FLAG_DRY_RUN" = true ]; then
      msg_info "[DRY-RUN] Would restore stashed changes."
    else
      msg_info "Re-applying your stashed local changes..."
      git stash pop
      msg_success "Your local changes have been restored."
    fi
  fi

  # --- Final Summary ---
  echo ""
  if [ "$FLAG_DRY_RUN" = true ]; then
    msg_success "[DRY-RUN] Update simulation complete."
    echo "  Would update from: v$old_version → v$new_version"
  else
    if [ "$old_version" != "$new_version" ]; then
      msg_success "The Dotfiles Flying Circus has been updated!"
      echo "  Updated from: v$old_version → v$new_version"
    else
      msg_success "The Dotfiles Flying Circus is now up-to-date. (v$new_version)"
    fi
  fi
}

main "$@"
