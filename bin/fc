#!/usr/bin/env bash

# ==============================================================================
#
# FILE:         fc (Dotfiles Flying Circus)
#
# DESCRIPTION:  This script is the main entry point and dispatcher for a suite
#               of custom shell commands. It uses a plugin-based architecture
#               to discover and execute subcommands.
#
# USAGE:        fc [global options] <command> [command options]
#
# ==============================================================================

# --- Initialization ---------------------------------------------------------
# Source the centralized initialization script to set up the environment.
source "$(dirname "${BASH_SOURCE[0]}")/../lib/init.sh"

# --- Configuration ----------------------------------------------------------
# Define the absolute path to the directory where plugins are stored.
readonly PLUGIN_DIR="$DOTFILES_ROOT/lib/plugins"

# --- Help and Usage ---------------------------------------------------------
usage() {
  msg_info "Usage: fc [global options] <command> [command options]"
  echo ""
  msg_info "Global Options:"
  echo "  --log-file <path>  Redirect all log output to the specified file."
  echo "  --log-level <lvl>  Set the console log level (DEBUG, INFO, WARN, ERROR, CRITICAL)."
  echo "  --silent           Suppress all output except critical errors."
  echo ""
  msg_info "A modular, plugin-based command-line utility for system management."
  echo ""
  msg_info "Available commands:"
  # Use -perm for macOS compatibility (-executable is a GNU extension)
  find "$PLUGIN_DIR" -maxdepth 1 -type f -perm +111 -exec basename {} \; | sort
  echo ""
  msg_info "Run 'fc <command> --help' for more information on a specific command."
  exit 0
}

# --- Main Dispatcher Logic --------------------------------------------------

# First, parse any global options before we look for the subcommand.
while [[ $# -gt 0 ]]; do
  case "$1" in
    --log-file)
      export LOG_FILE_PATH="$2"
      mkdir -p "$(dirname "$LOG_FILE_PATH")"
      touch "$LOG_FILE_PATH"
      shift 2
      ;;
    --log-level)
      level_name=$(echo "$2" | tr '[:lower:]' '[:upper:]')
      case "$level_name" in
        DEBUG) export CONSOLE_LOG_LEVEL=$LOG_LEVEL_DEBUG ;; 
        INFO) export CONSOLE_LOG_LEVEL=$LOG_LEVEL_INFO ;; 
        WARN) export CONSOLE_LOG_LEVEL=$LOG_LEVEL_WARN ;; 
        ERROR) export CONSOLE_LOG_LEVEL=$LOG_LEVEL_ERROR ;; 
        CRITICAL) export CONSOLE_LOG_LEVEL=$LOG_LEVEL_CRITICAL ;; 
        *) die "Invalid log level: $2. Use DEBUG, INFO, WARN, ERROR, or CRITICAL." ;;
      esac
      shift 2
      ;;
    --silent)
      export CONSOLE_LOG_LEVEL=$LOG_LEVEL_CRITICAL
      shift
      ;;
    --help)
      usage
      ;;
    # If the argument is not a recognized flag, we assume it's the subcommand.
    *)
      break
      ;;
  esac
done

# If no arguments are left, it means no subcommand was provided.
if [ -z "$1" ]; then
  usage
fi

# The first remaining argument is the subcommand.
SUBCOMMAND="$1"
PLUGIN_SCRIPT="$PLUGIN_DIR/$SUBCOMMAND"

# Check if the plugin script exists and is executable.
if [ -x "$PLUGIN_SCRIPT" ]; then
  shift
  # We use `source` instead of `exec` here to ensure that the script runs
  # in the current shell environment, which is critical for the `bats-mock`
  # testing framework to work correctly. `exec` replaces the current process,
  # which would cause the mock environment to be lost.
  source "$PLUGIN_SCRIPT" "$@"
else
  die "Unknown command '$SUBCOMMAND'. Run 'fc --help' to see a list of available commands."
fi
