#!/usr/bin/env bash

# ==============================================================================
#
# FILE:         fc (Dotfiles Flying Circus)
#
# DESCRIPTION:  This script is the main entry point and dispatcher for a suite
#               of custom shell commands. It uses a plugin-based architecture
#               to discover and execute subcommands.
#
# USAGE:        fc [global options] <command> [command options]
#
# ==============================================================================

# --- Initialization ---------------------------------------------------------
# Source the centralized initialization script to set up the environment.
source "$(dirname "${BASH_SOURCE[0]}")/../lib/init.sh"

# --- Configuration ----------------------------------------------------------
# Define the absolute path to the directory where plugins are stored.
readonly PLUGIN_DIR="$DOTFILES_ROOT/lib/plugins"

# --- Help and Usage ---------------------------------------------------------
usage() {
  ui_print_banner_mini
  echo ""

  echo "Usage: fc [global options] <command> [command options]"
  echo ""

  ui_header "Global Options"
  ui_list_item "--log-file <path>" 2 "Redirect all log output to the specified file."
  ui_list_item "--log-level <lvl>" 2 "Set the console log level (DEBUG, INFO, WARN, ERROR)."

  ui_header "Available Commands"

  # Group commands for better readability (simple logic: all are in 'System' for now unless we parse them)
  # For now, we'll list them in a clean 2-column format

  local commands=()
  while IFS= read -r cmd; do
    commands+=("$cmd")
  done < <(find "$PLUGIN_DIR" -maxdepth 1 -type f -executable -exec basename {} \; | sort)

  # Calculate mid point
  local total=${#commands[@]}
  local half=$(( (total + 1) / 2 ))

  for ((i=0; i<half; i++)); do
    local left="${commands[$i]}"
    local right=""
    if [[ $((i + half)) -lt $total ]]; then
      right="${commands[$((i + half))]}"
    fi

    # Print formatted columns
    printf "  %-30s %-30s\n" "$left" "$right"
  done

  echo ""
  ui_notice "info" "Run 'fc <command> --help' for details on a specific command."
  exit 0
}

# --- Main Dispatcher Logic --------------------------------------------------

# First, parse any global options before we look for the subcommand.
while [[ $# -gt 0 ]]; do
  case "$1" in
    --log-file)
      export LOG_FILE_PATH="$2"
      mkdir -p "$(dirname "$LOG_FILE_PATH")"
      touch "$LOG_FILE_PATH"
      shift 2
      ;;
    --log-level)
      level_name=$(echo "$2" | tr '[:lower:]' '[:upper:]')
      case "$level_name" in
        DEBUG) export CONSOLE_LOG_LEVEL=$LOG_LEVEL_DEBUG ;; 
        INFO) export CONSOLE_LOG_LEVEL=$LOG_LEVEL_INFO ;; 
        WARN) export CONSOLE_LOG_LEVEL=$LOG_LEVEL_WARN ;; 
        ERROR) export CONSOLE_LOG_LEVEL=$LOG_LEVEL_ERROR ;; 
        CRITICAL) export CONSOLE_LOG_LEVEL=$LOG_LEVEL_CRITICAL ;; 
        *) die "Invalid log level: $2. Use DEBUG, INFO, WARN, or ERROR." ;;
      esac
      shift 2
      ;;
    --help)
      usage
      ;;
    # If the argument is not a recognized flag, we assume it's the subcommand.
    *)
      break
      ;;
  esac
done

# If no arguments are left, it means no subcommand was provided.
if [ -z "$1" ]; then
  usage
fi

# The first remaining argument is the subcommand.
SUBCOMMAND="$1"
PLUGIN_SCRIPT="$PLUGIN_DIR/$SUBCOMMAND"

# Check if the plugin script exists and is executable.
if [ -x "$PLUGIN_SCRIPT" ]; then
  shift
  # We use `source` instead of `exec` here to ensure that the script runs
  # in the current shell environment, which is critical for the `bats-mock`
  # testing framework to work correctly. `exec` replaces the current process,
  # which would cause the mock environment to be lost.
  source "$PLUGIN_SCRIPT" "$@"
else
  die "Unknown command '$SUBCOMMAND'. Run 'fc --help' to see a list of available commands."
fi
